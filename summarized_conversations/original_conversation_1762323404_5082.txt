{'role': 'assistant', 'content': '<function_calls>\n<full-file-rewrite file_path="HEX-Control-Nexus/backend/node_webhooks/index.js">\nconst express = require(\'express\');\nconst http = require(\'http\');\nconst WebSocket = require(\'ws\');\nconst path = require(\'path\');\nconst { triggerPuppeteerTask } = require(\'./puppeteer_tasks\');\n\nconst app = express();\nconst server = http.createServer(app);\nconst wss = new WebSocket.Server({ server });\n\n// Middleware\napp.use(express.json());\napp.use(express.static(\'public\'));\n\n// Store for job statuses\nconst jobs = new Map();\n\n// WebSocket connection handling\nwss.on(\'connection\', (ws) => {\n  console.log(\'Client connected to WebSocket\');\n  \n  // Send initial connection message\n  ws.send(JSON.stringify({\n    type: \'connection\',\n    message: \'Connected to HEX Control Nexus WebSocket\'\n  }));\n  \n  // Handle incoming messages from clients\n  ws.on(\'message\', (message) => {\n    try {\n      const data = JSON.parse(message);\n      console.log(\'Received message:\', data);\n      \n      // Echo the message back\n      ws.send(JSON.stringify({\n        type: \'echo\',\n        message: `Echo: ${data.message || \'No message\'}`\n      }));\n    } catch (error) {\n      console.error(\'Error parsing WebSocket message:\', error);\n    }\n  });\n  \n  ws.on(\'close\', () => {\n    console.log(\'Client disconnected from WebSocket\');\n  });\n});\n\n// Helper function to broadcast to all WebSocket clients\nfunction broadcast(data) {\n  const message = JSON.stringify(data);\n  wss.clients.forEach((client) => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(message);\n    }\n  });\n}\n\n// Webhook endpoint\napp.post(\'/webhook\', async (req, res) => {\n  try {\n    const { task, target, options } = req.body;\n    \n    // Generate job ID\n    const jobId = `job_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    // Store job info\n    const jobInfo = {\n      id: jobId,\n      task,\n      target,\n      options,\n      status: \'queued\',\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString()\n    };\n    \n    jobs.set(jobId, jobInfo);\n    \n    // Broadcast job creation\n    broadcast({\n      type: \'job_created\',\n      job: jobInfo\n    });\n    \n    // Respond immediately with job ID\n    res.status(202).json({\n      jobId,\n      message: \'Job queued successfully\',\n      status: \'queued\'\n    });\n    \n    // Process the job asynchronously\n    processJob(jobId, task, target, options);\n    \n  } catch (error) {\n    console.error(\'Webhook error:\', error);\n    res.status(500).json({\n      error: \'Internal server error\',\n      message: error.message\n    });\n  }\n});\n\n// Process job function\nasync function processJob(jobId, task, target, options) {\n  try {\n    // Update job status\n    const job = jobs.get(jobId);\n    if (!job) return;\n    \n    job.status = \'processing\';\n    job.startedAt = new Date().toISOString();\n    job.updatedAt = new Date().toISOString();\n    \n    jobs.set(jobId, job);\n    \n    // Broadcast status update\n    broadcast({\n      type: \'job_status\',\n      job\n    });\n    \n    // Process based on task type\n    let result;\n    switch (task) {\n      case \'puppeteer\':\n        result = await triggerPuppeteerTask(target, options);\n        break;\n      case \'scrape\':\n        result = { message: `Scraped target: ${target}`, data: {} };\n        break;\n      case \'api_call\':\n        result = { message: `API call to: ${target}`, data: {} };\n        break;\n      default:\n        result = { message: `Executed task: ${task}`, data: {} };\n    }\n    \n    // Update job as completed\n    job.status = \'completed\';\n    job.result = result;\n    job.completedAt = new Date().toISOString();\n    job.updatedAt = new Date().toISOString();\n    \n    jobs.set(jobId, job);\n    \n    // Broadcast completion\n    broadcast({\n      type: \'job_completed\',\n      job\n    });\n    \n  } catch (error) {\n    console.error(`Job ${jobId} failed:`, error);\n    \n    // Update job as failed\n    const job = jobs.get(jobId);\n    if (job) {\n      job.status = \'failed\';\n      job.error = error.message;\n      job.failedAt = new Date().toISOString();\n      job.updatedAt = new Date().t...\n The full message content is stored at /workspace/summarized_conversations/original_conversation_1762323268_5306.txt'}